<?xml version="1.0" encoding="UTF-8"?>
<assessmentItem xmlns="http://www.imsglobal.org/xsd/imsqti_v2p1"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:ma="http://mathassess.qtitools.org/xsd/mathassess"
	xsi:schemaLocation="http://www.imsglobal.org/xsd/imsqti_v2p1 imsqti_v2p1.xsd 
 http://mathassess.qtitools.org/xsd/mathassess mathassess.xsd"
	xmlns:m="http://www.w3.org/1998/Math/MathML" adaptive="true" timeDependent="false"
	identifier="MAD01-SRinCO"
	title="Rand-ScriptRule-MathEntry-CasCompare - Expand brackets in a(x+b)+cx and simplify">
	<!-- This is MAD01-SRinRPRealCode.xml -->
	<!-- 
template processing with randomisation using ScriptRule, MathEntryInteraction and casCompare in response processing
-->
	<responseDeclaration identifier="RESPONSE" cardinality="record"/>
	<responseDeclaration baseType="string" cardinality="single" identifier="printMath"/>
	<responseDeclaration baseType="boolean" cardinality="single" identifier="HINTREQUEST"/>
	<responseDeclaration baseType="boolean" cardinality="single" identifier="SOLREQUEST"/>
	<outcomeDeclaration baseType="identifier" cardinality="multiple" identifier="FEEDBACK"/>
	<outcomeDeclaration baseType="identifier" cardinality="single" identifier="EMPTY"/>
	<outcomeDeclaration baseType="float" cardinality="single" identifier="SCORE" normalMaximum="2.0"
		normalMinimum="0.0">
		<defaultValue>
			<value>0.0</value>
		</defaultValue>
	</outcomeDeclaration>
	<outcomeDeclaration baseType="boolean" cardinality="single" identifier="seenSolution">
		<defaultValue>
			<value>false</value>
		</defaultValue>
	</outcomeDeclaration>
	<outcomeDeclaration baseType="boolean" cardinality="single" identifier="seenHint">
		<defaultValue>
			<value>false</value>
		</defaultValue>
	</outcomeDeclaration>
	<outcomeDeclaration baseType="identifier" cardinality="single" identifier="ASKHINT">
		<defaultValue>
			<value>askhint</value>
		</defaultValue>
	</outcomeDeclaration>
	<outcomeDeclaration baseType="identifier" cardinality="single" identifier="ASKSOLUTION">
		<defaultValue>
			<value>asksolution</value>
		</defaultValue>
	</outcomeDeclaration>
	<outcomeDeclaration identifier="odummy" cardinality="single" baseType="boolean"/>
	<outcomeDeclaration identifier="ordOK" cardinality="single" baseType="boolean"/>
	<outcomeDeclaration identifier="constOK" cardinality="single" baseType="boolean"/>
	<outcomeDeclaration identifier="constEquiv" cardinality="single" baseType="boolean"/>
	<outcomeDeclaration identifier="termsOK" cardinality="single" baseType="boolean"/>
	<outcomeDeclaration identifier="isEquiv" cardinality="single" baseType="boolean"/>
	<outcomeDeclaration identifier="mSub" cardinality="record"/>
	<outcomeDeclaration identifier="iTerms" cardinality="single" baseType="integer"/>
	<outcomeDeclaration identifier="oA" cardinality="single" baseType="integer"/>
	<outcomeDeclaration identifier="iMaxPow" cardinality="single" baseType="integer"/>
	<outcomeDeclaration identifier="iConstR" cardinality="single" baseType="integer"/>
	<outcomeDeclaration identifier="iConstA" cardinality="single" baseType="integer"/>
	<!-- add template processing, using QTIv2.1 native elements -->
	<templateDeclaration baseType="boolean" cardinality="single" identifier="keepRandomSeed"
		mathVariable="false" paramVariable="false"/>
	<templateDeclaration baseType="integer" cardinality="single" identifier="iRandomSeed"
		mathVariable="false" paramVariable="false"/>
	<templateDeclaration baseType="boolean" cardinality="single" identifier="dummy"
		mathVariable="false" paramVariable="false"/>
	<templateDeclaration baseType="identifier" cardinality="multiple" identifier="showSolParts"
		mathVariable="false" paramVariable="false"/>
	<templateDeclaration baseType="integer" cardinality="single" identifier="iA" mathVariable="true"
		paramVariable="false">
		<defaultValue>
			<value>0</value>
		</defaultValue>
	</templateDeclaration>
	<templateDeclaration baseType="integer" cardinality="single" identifier="iAbsA"
		mathVariable="true" paramVariable="false"/>
	<templateDeclaration baseType="integer" cardinality="single" identifier="iB" mathVariable="true"
		paramVariable="false">
		<defaultValue>
			<value>0</value>
		</defaultValue>
	</templateDeclaration>
	<templateDeclaration baseType="integer" cardinality="single" identifier="iAbsB"
		mathVariable="true" paramVariable="false"/>
	<templateDeclaration cardinality="single" baseType="string" identifier="sSignB"
		mathVariable="true" paramVariable="false"/>
	<templateDeclaration baseType="integer" cardinality="single" identifier="iC" mathVariable="true"
		paramVariable="false">
		<defaultValue>
			<value>0</value>
		</defaultValue>
	</templateDeclaration>
	<templateDeclaration baseType="integer" cardinality="single" identifier="iAbsC"
		mathVariable="true" paramVariable="false"/>
	<templateDeclaration cardinality="single" baseType="string" identifier="sSignC"
		mathVariable="true" paramVariable="false"/>
	<templateDeclaration baseType="integer" cardinality="single" identifier="iAB"
		mathVariable="true" paramVariable="false"/>
	<templateDeclaration baseType="integer" cardinality="single" identifier="iAbsAB"
		mathVariable="true" paramVariable="false"/>
	<templateDeclaration cardinality="single" baseType="string" identifier="sSignAB"
		mathVariable="true" paramVariable="false"/>
	<templateDeclaration cardinality="single" baseType="string" identifier="sBadSignAB"
		mathVariable="true" paramVariable="false"/>
	<templateDeclaration baseType="integer" cardinality="single" identifier="iApC"
		mathVariable="true" paramVariable="false"/>
	<templateDeclaration cardinality="record" identifier="mX" mathVariable="true"
		paramVariable="false"/>
	<templateDeclaration cardinality="record" identifier="mQues" mathVariable="true"
		paramVariable="false"/>
	<templateDeclaration cardinality="record" identifier="mAns" mathVariable="true"
		paramVariable="false"/>
	<templateDeclaration baseType="integer" cardinality="single" identifier="iBad3"
		mathVariable="false" paramVariable="false"/>
	<templateDeclaration cardinality="record" identifier="mBad3" mathVariable="true"
		paramVariable="false"/>
	<templateDeclaration cardinality="record" identifier="mBad4" mathVariable="true"
		paramVariable="false"/>
	<templateDeclaration cardinality="record" identifier="mBad5" mathVariable="true"
		paramVariable="false"/>
	<templateDeclaration baseType="integer" cardinality="single" identifier="iBad5"
		mathVariable="false" paramVariable="false"/>
	<templateDeclaration baseType="integer" cardinality="ordered" identifier="iRandomState"
		mathVariable="false" paramVariable="false"/>
	<templateProcessing>
		<!-- now do the randomisation and mathematical calculations, using maxima -->
		<setTemplateValue identifier="dummy">
			<customOperator class="org.qtitools.mathassess.ScriptRule" ma:syntax="text/x-maxima">
				<baseValue baseType="string">
					<![CDATA[
				simp:true;
				s1 : make_random_state(true)$ set_random_state(s1);
				for iI:1 step 1 unless (not(equal((iA+iC),0)) and not(equal(abs(iA+iC),1)) and gcd(iA*iB,iA+iC)=1) do block(
				  iA: ev((random(9)+2)*(random(2)*2-1),simp),
				  iB: ev((random(9)+1)*(random(2)*2-1),simp),
				  iC: ev((random(9)+2)*(random(2)*2-1),simp));
				iAbsA: ev(abs(iA),simp);
				iAbsB: ev(abs(iB),simp);
				iAbsC: ev(abs(iC),simp);
				iAB: ev(iA*iB,simp);
				iApC: ev(iA+iC,simp);
				iAbsAB: ev(abs(iAB),simp);
				array(aarr,19);
				fillarray(aarr,[a,b,c,d,g,h,k,m,n,p,q,r,s,t,u,v,w,x,y,z]);
				mX:aarr[random(19)];
				mBad3:ev(iAB-iB,simp);
				mBad4:(iA-1)*mX;
				mBad5:ev(2*iAB,simp);
				simp:false;
				mQues:iA*(mX+iB)+iC*mX;
				if iAB>0 then mAns:ev(iApC*mX,simp)+iAB else mAns:ev(iApC*mX,simp)-iAbsAB;
				]]>
				</baseValue>
			</customOperator>
		</setTemplateValue>
		<templateCondition>
			<templateIf>
				<gt>
					<variable identifier="iB"/>
					<baseValue baseType="integer">0</baseValue>
				</gt>
				<setTemplateValue identifier="sSignB">
					<baseValue baseType="string">+</baseValue>
				</setTemplateValue>
			</templateIf>
			<templateElse>
				<setTemplateValue identifier="sSignB">
					<baseValue baseType="string">-</baseValue>
				</setTemplateValue>
			</templateElse>
		</templateCondition>
		<templateCondition>
			<templateIf>
				<gt>
					<variable identifier="iC"/>
					<baseValue baseType="integer">0</baseValue>
				</gt>
				<setTemplateValue identifier="sSignC">
					<baseValue baseType="string">+</baseValue>
				</setTemplateValue>
			</templateIf>
			<templateElse>
				<setTemplateValue identifier="sSignC">
					<baseValue baseType="string">-</baseValue>
				</setTemplateValue>
			</templateElse>
		</templateCondition>
		<templateCondition>
			<templateIf>
				<gt>
					<variable identifier="iAB"/>
					<baseValue baseType="integer">0</baseValue>
				</gt>
				<setTemplateValue identifier="sSignAB">
					<baseValue baseType="string">+</baseValue>
				</setTemplateValue>
				<setTemplateValue identifier="sBadSignAB">
					<baseValue baseType="string">-</baseValue>
				</setTemplateValue>
			</templateIf>
			<templateElse>
				<setTemplateValue identifier="sSignAB">
					<baseValue baseType="string">-</baseValue>
				</setTemplateValue>
				<setTemplateValue identifier="sBadSignAB">
					<baseValue baseType="string">+</baseValue>
				</setTemplateValue>
			</templateElse>
		</templateCondition>
	</templateProcessing>
	<itemBody>
		<!-- templateVariables are used in the question statement, choices and feedback,
		including some of type string with mathVariable set; printedVariable for these should produce MathML -->
		<p>Expand the brackets in <m:math>
				<m:semantics>
					<m:mrow>
						<m:mi>iA</m:mi>
						<m:mo>(</m:mo>
						<m:mi>mX</m:mi>
						<!-- Using variable substitution for our random letter (QTI extension) -->
						<m:mi>sSignB</m:mi>
						<!-- Using variable substitution in mo (QTI extension) -->
						<m:mi>iAbsB</m:mi>
						<m:mo>)</m:mo>
						<m:mi>sSignC</m:mi>
						<!-- Using variable substitution in mo (QTI extension) -->
						<m:mi>iAbsC</m:mi>
						<m:mi>mX</m:mi>
						<!-- Using variable substitution for our random letter (QTI extension) -->
					</m:mrow>
					<m:annotation encoding="LaTeX"
						>\[\qv{iA}(\qv{mX}\qv{sSignB}\qv{iAbsB})\qv{sSignC}\qv{iAbsC}\qv{mX}\]</m:annotation>
				</m:semantics>
			</m:math> and simplify the result. </p>
		<table>
			<tbody>
				<tr>
					<td>
						<customInteraction class="org.qtitools.mathassess.MathEntryInteraction"
							responseIdentifier="RESPONSE" ma:syntax="text/x-maxima"
							ma:expectedLength="20" ma:printIdentifier="printMath"/>
					</td>
					<td>
						<feedbackInline identifier="CORRECT" outcomeIdentifier="FEEDBACK"
							showHide="show"> Correct </feedbackInline>
						<feedbackInline identifier="CORRECT-ORD" outcomeIdentifier="FEEDBACK"
							showHide="show"> Your answer is correct, but it would be more usual to
							write it in the form &#160;&#160; <m:math display="block">
								<m:semantics>
									<m:mrow>
										<m:mi>iApC</m:mi>
										<m:mi>mX</m:mi>
										<!-- Using string variable substitution for our random letter (QTI extension) -->
										<m:mi>sSignAB</m:mi>
										<!-- Using string variable substitution in mo (QTI extension) -->
										<m:mi>iAbsAB</m:mi>
									</m:mrow>
									<m:annotation encoding="LaTeX"
										>\[\qv{iApC}\qv{mX}\qv{sSignAB}\qv{iAbsAB}\]</m:annotation>
								</m:semantics>
							</m:math>. </feedbackInline>
						<feedbackInline identifier="NOT-SIMP" outcomeIdentifier="FEEDBACK"
							showHide="show"> You have expanded the bracket correctly but failed to
							simplify as the question asks. </feedbackInline>
						<feedbackInline identifier="NOT-ALL-MULT" outcomeIdentifier="FEEDBACK"
							showHide="show"> Remember that, when expanding brackets, all terms
							inside must be multiplied by whatever is outside. However, you got one
							term in the answer correct. </feedbackInline>
						<feedbackInline identifier="WRONG-SIGN-CONSTANT"
							outcomeIdentifier="FEEDBACK" showHide="show"> When expanding the bracket
							the product of <printedVariable identifier="iA"/> and <printedVariable
								identifier="iB"/> is <printedVariable identifier="iAB"/>. However,
							you got one term in the answer correct. </feedbackInline>
						<feedbackInline identifier="ORIG-EXPR" outcomeIdentifier="FEEDBACK"
							showHide="show"> Your input is equivalent to the expression we started
							with! </feedbackInline>
						<feedbackInline identifier="INCORRECT" outcomeIdentifier="FEEDBACK"
							showHide="show"> You should ask for tutor help on this question.
						</feedbackInline>
					</td>
				</tr>
			</tbody>
		</table>

		<feedbackBlock identifier="SOLUTION" outcomeIdentifier="FEEDBACK" showHide="show">
			<div>
				<m:math display="block" id="mathML7">
					<m:semantics>
						<m:mtable>
							<m:mtr>
								<m:mtd columnalign="right">
									<m:mi>iA</m:mi>
									<m:mfenced close=")" open="(">
										<m:mrow>
											<m:mi>mX</m:mi>
											<m:mi>sSignB</m:mi>
											<m:mi>iAbsB</m:mi>
										</m:mrow>
									</m:mfenced>
									<m:mi>sSignC</m:mi>
									<m:mi>iAbsC</m:mi>
									<m:mi>mX</m:mi>
								</m:mtd>
								<m:mtd columnalign="center">
									<m:mo>=</m:mo>
								</m:mtd>
								<m:mtd columnalign="left">
									<m:mi>iA</m:mi>
									<m:mo>×</m:mo>
									<m:mi>mX</m:mi>
									<m:mi>sSignAB</m:mi>
									<m:mi>iAbsA</m:mi>
									<m:mo>×</m:mo>
									<m:mi>iAbsB</m:mi>
									<m:mi>sSignC</m:mi>
									<m:mi>iAbsC</m:mi>
									<m:mo>×</m:mo>
									<m:mi>mX</m:mi>
								</m:mtd>
							</m:mtr>
							<m:mtr>
								<m:mtd columnalign="right"/>
								<m:mtd columnalign="center">
									<m:mo>=</m:mo>
								</m:mtd>
								<m:mtd columnalign="left">
									<m:mi>iApC</m:mi>
									<m:mi>mX</m:mi>
									<m:mi>sSignAB</m:mi>
									<m:mi>iAbsAB</m:mi>
								</m:mtd>
							</m:mtr>
						</m:mtable>
						<m:annotation encoding="SnuggleTeX">\begin{eqnarray*}\qv{iA}(\qv{mX}
							\qv{sSignB} \qv{iAbsB}) \qv{sSignC} \qv{iAbsC} \qv{mX} &amp;=&amp;
							\qv{iA} \times \qv{mX} \qv{sSignAB} \qv{iAbsA} \times \qv{iAbsB}
							\qv{sSignC} \qv{iAbsC} \times \qv{mX}\\ &amp;=&amp; \qv{iApC} \qv{mX}
							\qv{sSignAB} \qv{iAbsAB}\end{eqnarray*}</m:annotation>
					</m:semantics>
				</m:math>
			</div>
		</feedbackBlock>
		<feedbackBlock identifier="HINT" outcomeIdentifier="FEEDBACK" showHide="show">
			<p>Expand the bracket and collect like terms.</p>
		</feedbackBlock>
		<feedbackBlock identifier="SEEN-SOLUTION" outcomeIdentifier="FEEDBACK" showHide="show">
			<p> Since you have viewed the solution, your score for this question will be 0. </p>
		</feedbackBlock>
		<feedbackBlock identifier="SEEN-HINT" outcomeIdentifier="FEEDBACK" showHide="show">
			<p> Since you have viewed the hint, your score for this question will be halved. </p>
		</feedbackBlock>
		<feedbackBlock identifier="askhint" outcomeIdentifier="ASKHINT" showHide="show">
			<p>
				<endAttemptInteraction id="endAttemptInteraction1" responseIdentifier="HINTREQUEST"
					title="Show Hint"/>
			</p>
		</feedbackBlock>
		<feedbackBlock identifier="asksolution" outcomeIdentifier="ASKSOLUTION" showHide="show">
			<p>
				<endAttemptInteraction id="endAttemptInteraction2" responseIdentifier="SOLREQUEST"
					title="Show Solution"/>
			</p>
		</feedbackBlock>
	</itemBody>
	<responseProcessing>
		<!-- basic match, includes feedback on specific errors -->
		<setOutcomeValue identifier="FEEDBACK">
			<multiple>
				<variable identifier="EMPTY"/>
			</multiple>
		</setOutcomeValue>
		<responseCondition>
			<responseIf>
				<variable identifier="HINTREQUEST"/>
				<setOutcomeValue identifier="FEEDBACK">
					<multiple>
						<baseValue baseType="identifier">HINT</baseValue>
					</multiple>
				</setOutcomeValue>
				<setOutcomeValue identifier="seenHint">
					<baseValue baseType="boolean">true</baseValue>
				</setOutcomeValue>
			</responseIf>
			<responseElseIf>
				<variable identifier="SOLREQUEST"/>
				<setOutcomeValue identifier="FEEDBACK">
					<multiple>
						<baseValue baseType="identifier">SOLUTION</baseValue>
					</multiple>
				</setOutcomeValue>
				<setOutcomeValue identifier="seenSolution">
					<baseValue baseType="boolean">true</baseValue>
				</setOutcomeValue>
				<setOutcomeValue identifier="completionStatus">
					<baseValue baseType="identifier">completed</baseValue>
				</setOutcomeValue>
				<setOutcomeValue identifier="ASKHINT">
					<baseValue baseType="identifier">null</baseValue>
				</setOutcomeValue>
				<setOutcomeValue identifier="ASKSOLUTION">
					<baseValue baseType="identifier">null</baseValue>
				</setOutcomeValue>
			</responseElseIf>
			<responseElse>
				<responseCondition>
					<responseIf>
						<isNull>
							<variable identifier="RESPONSE"/>
						</isNull>
						<setOutcomeValue identifier="SCORE">
							<baseValue baseType="float">0</baseValue>
						</setOutcomeValue>
					</responseIf>
					<responseElse>
						<setOutcomeValue identifier="odummy">
							<customOperator class="org.qtitools.mathassess.ScriptRule"
								ma:syntax="text/x-maxima" ma:simplify="false">
								<baseValue baseType="string">
									<![CDATA[
								iMaxPow: ev(hipow(RESPONSE,mX),numer);
								constR:coeff(RESPONSE,mX,0);
								constA:coeff(mAns,mX,0);
								if (constR=constA)then ordOK:true else ordOK:false;
								mSub: ev(mAns-RESPONSE,simp);
								if is(zeroequiv(mSub,mX)) then isEquiv:true else isEquiv:false;
								termsOK: is(equal(nterms(RESPONSE),2));
								iConstR: ev(ev(constR,simp),numer);
								iConstA: ev(ev(constA,simp),numer);
								if is(iConstR=iConstA) then constOK:true else constOK:false;
								if is(equal(constR,constA)) then constEquiv:true else constEquiv:false;
								]]>
								</baseValue>
							</customOperator>
						</setOutcomeValue>
						<!--  test code for checking SR operation
									oA:iA;
									iMaxPow: iAB;
									polyOK: true;
									mSub: ev(mAns-RESPONSE,simp);
									isEquiv: true;
									termsOK: true;
									iConst: iApC;
									constOK:true;
									constEquiv:true;
								   -->
						<responseCondition>
							<responseIf>
								<variable identifier="isEquiv"/>
								<responseCondition>
									<responseIf>
										<variable identifier="termsOK"/>
										<setOutcomeValue identifier="SCORE">
											<baseValue baseType="float">2</baseValue>
										</setOutcomeValue>
										<responseCondition>
											<responseIf>
												<variable identifier="ordOK"/>
												<setOutcomeValue identifier="FEEDBACK">
												<multiple>
												<baseValue baseType="identifier"
												>CORRECT</baseValue>
												</multiple>
												</setOutcomeValue>
											</responseIf>
											<responseElse>
												<setOutcomeValue identifier="FEEDBACK">
												<multiple>
												<baseValue baseType="identifier"
												>CORRECT-ORD</baseValue>
												</multiple>
												</setOutcomeValue>
											</responseElse>
										</responseCondition>
									</responseIf>
									<responseElse>
										<!-- wrong number of terms -->
										<responseCondition>
											<responseIf>
												<variable identifier="constEquiv"/>
												<setOutcomeValue identifier="SCORE">
												<baseValue baseType="float">1</baseValue>
												</setOutcomeValue>
												<setOutcomeValue identifier="FEEDBACK">
												<multiple>
												<baseValue baseType="identifier"
												>NOT-SIMP</baseValue>
												</multiple>
												</setOutcomeValue>
											</responseIf>
											<responseElse>
												<setOutcomeValue identifier="FEEDBACK">
												<multiple>
												<baseValue baseType="identifier"
												>ORIG-EXPR</baseValue>
												</multiple>
												</setOutcomeValue>
											</responseElse>
										</responseCondition>
									</responseElse>
								</responseCondition>
							</responseIf>
							<responseElse>
								<responseCondition>
									<responseIf>
										<customOperator class="org.qtitools.mathassess.CasCompare"
											ma:syntax="text/x-maxima" ma:action="equal"
											ma:simplify="true">
											<variable identifier="mSub"/>
											<variable identifier="mBad3"/>
										</customOperator>
										<setOutcomeValue identifier="FEEDBACK">
											<multiple>
												<baseValue baseType="identifier"
												>NOT-ALL-MULT</baseValue>
											</multiple>
										</setOutcomeValue>
										<setOutcomeValue identifier="SCORE">
											<baseValue baseType="float">1</baseValue>
										</setOutcomeValue>
									</responseIf>
									<responseElseIf>
										<customOperator class="org.qtitools.mathassess.CasCompare"
											ma:syntax="text/x-maxima" ma:action="equal"
											ma:simplify="true">
											<variable identifier="mSub"/>
											<variable identifier="mBad4"/>
										</customOperator>
										<setOutcomeValue identifier="FEEDBACK">
											<multiple>
												<baseValue baseType="identifier"
												>NOT-ALL-MULT</baseValue>
											</multiple>
										</setOutcomeValue>
										<setOutcomeValue identifier="SCORE">
											<baseValue baseType="float">1</baseValue>
										</setOutcomeValue>
									</responseElseIf>
									<responseElseIf>
										<customOperator class="org.qtitools.mathassess.CasCompare"
											ma:syntax="text/x-maxima" ma:action="equal"
											ma:simplify="true">
											<variable identifier="mSub"/>
											<variable identifier="mBad5"/>
										</customOperator>
										<setOutcomeValue identifier="FEEDBACK">
											<multiple>
												<baseValue baseType="identifier"
												>WRONG-SIGN-CONSTANT</baseValue>
											</multiple>
										</setOutcomeValue>
										<setOutcomeValue identifier="SCORE">
											<baseValue baseType="float">1</baseValue>
										</setOutcomeValue>
									</responseElseIf>
									<responseElse>
										<setOutcomeValue identifier="FEEDBACK">
											<multiple>
												<baseValue baseType="identifier"
												>INCORRECT</baseValue>
											</multiple>
										</setOutcomeValue>
										<setOutcomeValue identifier="SCORE">
											<baseValue baseType="float">0</baseValue>
										</setOutcomeValue>
									</responseElse>
								</responseCondition>
							</responseElse>
						</responseCondition>
						<setOutcomeValue identifier="completionStatus">
							<baseValue baseType="identifier">completed</baseValue>
						</setOutcomeValue>
						<setOutcomeValue identifier="ASKHINT">
							<baseValue baseType="identifier">null</baseValue>
						</setOutcomeValue>
						<setOutcomeValue identifier="ASKSOLUTION">
							<baseValue baseType="identifier">null</baseValue>
						</setOutcomeValue>
						<responseCondition>
							<responseIf>
								<variable identifier="seenSolution"/>
								<setOutcomeValue identifier="FEEDBACK">
									<multiple>
										<variable identifier="FEEDBACK"/>
										<baseValue baseType="identifier">SEEN-SOLUTION</baseValue>
									</multiple>
								</setOutcomeValue>
								<setOutcomeValue identifier="SCORE">
									<baseValue baseType="float">0.0</baseValue>
								</setOutcomeValue>
							</responseIf>
							<responseElseIf>
								<variable identifier="seenHint"/>
								<setOutcomeValue identifier="FEEDBACK">
									<multiple>
										<variable identifier="FEEDBACK"/>
										<baseValue baseType="identifier">SEEN-HINT</baseValue>
									</multiple>
								</setOutcomeValue>
								<setOutcomeValue identifier="SCORE">
									<divide>
										<variable identifier="SCORE"/>
										<baseValue baseType="float">2.0</baseValue>
									</divide>
								</setOutcomeValue>
							</responseElseIf>
						</responseCondition>
					</responseElse>
				</responseCondition>
			</responseElse>
		</responseCondition>
	</responseProcessing>
</assessmentItem>
